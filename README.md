# Homework #12

### Задача №1
Создайте массив строк cards. Этот массив должен содержать в себе 4 элемента. Каждый элемент должен состоять из 16 цифр.
Пример массива: 
```js
[
  '4567456745674567',
  '4282428242824282',
  '7224722472247224',
  '8147814781478147'
]
```
Перепишите функцию из задачи №3, домашнего задания №8 с использованием Promise.

В новой функции вам нужно завернуть setTimeout в Promise и вернуть получившийся Promise из функции (сообщение ‘Ваша ставка принята’ из функции возвращать не нужно). В setTimeout вывод сообщений ‘Вы выиграли. Ваш выигрыш составляет….’ и ‘Вы проиграли. Ваши деньги сгорели.’ заменить resolve и reject.
* В reject передавать строку 'Вы проиграли. Ваши деньги сгорели.'
* В reject передавать объект со следующими полями:

- message: `Вы выиграли. Ваш выигрыш составляет {сумма выигрыша}`,
- value: сумма выигрыша (число)

Напишите функцию для вывода выигрыша на карту. Функция должна принимать в качестве единственного аргумента сумму выигрыша. При старте функции, попросите пользователя ввести номер карты, на которую он хочет вывести свой выигрыш. Для запроса номера карты используйте prompt. После получения номера карты создайте Promise и верните его из функции. В созданном Promise с помощью setTimeout сымитируйте задержку при запросе на сервер (время задержки 3 секунды). В setTimeout реализуйте проверку наличия введённой карты в массиве cards. Для вывода результата используйте resolve, reject и передавайте в них следующие значения.

* В reject - 'Пользователя с таким номером карты не существует'
* В resolve - 'Ваш выигрыш в размере {сумма выигрыша из аргумента}, был выведен на карту с номером {введённый номер карты}. Поздравляем!'

Вызовите функцию для создания ставки. Т.к. теперь функция возвращает Promise, вам нужно использовать метод then() для получения результата работы функции.
Используйте .then() после вызова функции для создания ставки, передайте в него 2 функции. Первая функция для обработки resolve, вторая функция для обработки reject.
* Обработчик resolve должен выводить в консоль сообщение из поля message, полученного объекта, и возвращать вызов функции для вывода денег с полем value, полученного объекта, в качестве аргумента. (возвращать вызов функции нужно для организации работы асинхронного кода)
* Обработчик reject выводит полученный результат в консоль.

Т.к. функция для вывода денег возвращает Promise, то для получения результата её работы нам нужно использовать метод then() ещё раз (создать цепочку из then()).
После вызова первого then(), вызовите метод then() второй раз и передайте в него 2 функции для обработки resolve и reject. Каждая функция должна выводить в консоль полученный результат.

```js
const arrayStr = [
  '4567456745674567',
  '4282428242824282',
  '7224722472247224',
  '8147814781478147'
]

function xBet() {
  this.money = +prompt('Введите сумму ставки:')
  return new Promise((resolve, reject) => {
      let random = function(min = 5, max = -5) {
        return Math.floor(Math.random() * (max - min) + min)
      }
      if (this.money)
        setTimeout(() => {
          random() > 0 ? resolve({
            value: value = Math.abs(random() * this.money),
            message: `Вы выиграли. Ваш выигрыш составляет ${this.value}`
          }) : reject('Вы проиграли. Ваши деньги сгорели')
        }, 3000)
    }).then((value) => {
      console.log(value.message)
      let sum = value.value
      function bid(sum) {
        this.cardNumber = +prompt('Введите номер карты для вывода выиграша:')
        return new Promise((resolve, reject) => {
          if (this.cardNumber)
            setTimeout(() => {
              (arrayStr.includes(String(this.cardNumber))) 
                ? resolve(`Ваш выиграш в размере ${sum}, был выведен на карту с номером ${this.cardNumber}. Поздравляем!`)
                : reject('Пользователя с таким номером не сушествует')
            }, 3000)
        }).then((value) => console.log(value)).catch((value) => console.log(value))
      }
      bid(sum)
    })
    .catch((value) => console.log(value))
}

xBet()
```

***

### Задача №2

Напишите функцию для получения фото с сервера. Функция должна возвращать Promise. В созданном Promise сделайте GET-запрос на эндпоинт 'https://jsonplaceholder.typicode.com/photos' используя XMLHttpRequest. После отправки запроса добавьте только один обработчик onload. Функция-обработчик onload должна проверять равен ли статус числу 200. Если статус равен, то вызывать метод resolve. В метод резов передать ответ сервера. Если статус не равен, то вызывать метод reject и передавать ему следующую строку: 'Что-то пошло не так'.
Вызовите функцию. После вызова функции используйте метод then() для обработки полученных с сервера данных. В методы then() отфильтруйте полученный массив, и оставьте в нём только фото с id равным 1, 3, 5, 7, 9. В цикле для каждого элемента получившегося массива с помощью js создайте элемент img, добавьте созданному элементу поле src со значением url, обрабатываемого объекта, и добавьте созданный элемент в body.
Для обработки ошибки используйте метод catch. В метод catch передайте функцию, которая выводит полученное сообщение в консоль.

```js
(function() {
  const URL = 'https://jsonplaceholder.typicode.com/photos'
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest
    xhr.open('GET', URL)
    xhr.onload = function(event) {
      if(this.status === 200) {
        resolve(JSON.parse(this.response))
      }
      return reject('Что-то пошло не так')
    }
    xhr.send()
  })
})().then((response) => {
  const array = response
  const idPhoto = array.filter(item => item.id === 1 || item.id === 3 || item.id === 5 || item.id === 7 || item.id === 9)
  const body = document.querySelector('body')
  function drow() {
    idPhoto.forEach((elem) => {
      image = document.createElement('img')
      body.appendChild(image)
      image.src = elem.url
    })
  }
  drow()
}).catch((response) => console.log(response))
```
